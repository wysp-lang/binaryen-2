;; NOTE: Assertions have been generated by update_lit_checks.py and should not be edited.
;; RUN: foreach %s %t wasm-opt -all --efo --nominal -S -o - | filecheck %s

(module
  ;; CHECK:      (type $A (struct (field i32) (field i32)))
  (type $A (struct (field i32) (field i32)))
  ;; CHECK:      (type $B (struct (field i32) (field i32)))
  (type $B (struct (field i32) (field i32)))

  ;; CHECK:      (func $A (type $none_=>_none)
  ;; CHECK-NEXT:  (local $ref (ref $A))
  ;; CHECK-NEXT:  (local.set $ref
  ;; CHECK-NEXT:   (struct.new $A
  ;; CHECK-NEXT:    (i32.const 10)
  ;; CHECK-NEXT:    (i32.const 10)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $A 0
  ;; CHECK-NEXT:    (local.get $ref)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $A 0
  ;; CHECK-NEXT:    (local.get $ref)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (block ;; (replaces something unreachable we can't emit)
  ;; CHECK-NEXT:    (drop
  ;; CHECK-NEXT:     (unreachable)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (drop
  ;; CHECK-NEXT:     (i32.const 11)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (unreachable)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (block ;; (replaces something unreachable we can't emit)
  ;; CHECK-NEXT:    (drop
  ;; CHECK-NEXT:     (unreachable)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (unreachable)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $A
    (local $ref (ref $A))
    ;; $A is always written the same value in both fields, so they are
    ;; equivalent, and we optimize to always read from field #0.
    (local.set $ref
      (struct.new $A
        (i32.const 10)
        (i32.const 10)
      )
    )
    (drop
      (struct.get $A 0
        (local.get $ref)
      )
    )
    (drop
      (struct.get $A 1   ;; This will be optimized to 0.
        (local.get $ref)
      )
    )
    ;; Unreachable things are ignored, and do not interfere with optimization.
    (drop
      (struct.new $A
        (unreachable)
        (i32.const 11)
      )
    )
    (drop
      (struct.get $A 1
        (unreachable)
      )
    )
  )

  ;; CHECK:      (func $B (type $none_=>_none)
  ;; CHECK-NEXT:  (local $ref (ref $B))
  ;; CHECK-NEXT:  (local.set $ref
  ;; CHECK-NEXT:   (struct.new $B
  ;; CHECK-NEXT:    (i32.const 10)
  ;; CHECK-NEXT:    (i32.const 11)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $B 0
  ;; CHECK-NEXT:    (local.get $ref)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $B 1
  ;; CHECK-NEXT:    (local.get $ref)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $B
    (local $ref (ref $B))
    (local.set $ref
      (struct.new $B
        (i32.const 10)
        (i32.const 11) ;; This value is different, so in this function we do not
                       ;; optimize at all, and the get indexes remain 0, 1.
      )
    )
    (drop
      (struct.get $B 0
        (local.get $ref)
      )
    )
    (drop
      (struct.get $B 1
        (local.get $ref)
      )
    )
  )
)

(module
  ;; CHECK:      (type $A (struct (field i32) (field i32)))
  (type $A (struct (field i32) (field i32)))

  ;; CHECK:      (func $A (type $i32_=>_none) (param $x i32)
  ;; CHECK-NEXT:  (local $ref (ref null $A))
  ;; CHECK-NEXT:  (if
  ;; CHECK-NEXT:   (local.get $x)
  ;; CHECK-NEXT:   (local.set $ref
  ;; CHECK-NEXT:    (struct.new $A
  ;; CHECK-NEXT:     (i32.const 10)
  ;; CHECK-NEXT:     (i32.const 10)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:   (local.set $ref
  ;; CHECK-NEXT:    (struct.new $A
  ;; CHECK-NEXT:     (i32.const 20)
  ;; CHECK-NEXT:     (i32.const 20)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.new_default $A)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $A 1
  ;; CHECK-NEXT:    (local.get $ref)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $A (param $x i32)
    (local $ref (ref null $A))
    ;; As above, but now there is a struct.new_with_default later, which
    ;; prevents optimization, as we do not handle that atm. TODO
    (if
      (local.get $x)
      (local.set $ref
        (struct.new $A
          (i32.const 10)
          (i32.const 10)
        )
      )
      (local.set $ref
        (struct.new $A
          (i32.const 20)
          (i32.const 20)
        )
      )
    )
    (drop
      (struct.new_default $A)
    )
    (drop
      (struct.get $A 1 ;; This will stay #1, and not get optimized to 0.
        (local.get $ref)
      )
    )
  )
)

(module
  ;; CHECK:      (type $A (struct (field i32) (field i32)))
  (type $A (struct (field i32) (field i32)))

  ;; CHECK:      (func $A (type $i32_=>_none) (param $x i32)
  ;; CHECK-NEXT:  (local $ref (ref null $A))
  ;; CHECK-NEXT:  (if
  ;; CHECK-NEXT:   (local.get $x)
  ;; CHECK-NEXT:   (local.set $ref
  ;; CHECK-NEXT:    (struct.new $A
  ;; CHECK-NEXT:     (i32.const 10)
  ;; CHECK-NEXT:     (i32.const 10)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:   (local.set $ref
  ;; CHECK-NEXT:    (struct.new $A
  ;; CHECK-NEXT:     (i32.const 20)
  ;; CHECK-NEXT:     (i32.const 20)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $A 0
  ;; CHECK-NEXT:    (local.get $ref)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $A (param $x i32)
    (local $ref (ref null $A))
    ;; Two struct.news, each with different values - but the equivalances are
    ;; the same in both, so we can optimize the get index below to 0.
    (if
      (local.get $x)
      (local.set $ref
        (struct.new $A
          (i32.const 10)
          (i32.const 10)
        )
      )
      (local.set $ref
        (struct.new $A
          (i32.const 20)
          (i32.const 20)
        )
      )
    )
    (drop
      (struct.get $A 1
        (local.get $ref)
      )
    )
  )
)

(module
  ;; CHECK:      (type $A (struct (field i32) (field i32)))
  (type $A (struct (field i32) (field i32)))

  ;; CHECK:      (func $A (type $i32_=>_none) (param $x i32)
  ;; CHECK-NEXT:  (local $ref (ref null $A))
  ;; CHECK-NEXT:  (if
  ;; CHECK-NEXT:   (local.get $x)
  ;; CHECK-NEXT:   (local.set $ref
  ;; CHECK-NEXT:    (struct.new $A
  ;; CHECK-NEXT:     (i32.const 10)
  ;; CHECK-NEXT:     (i32.const 10)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:   (local.set $ref
  ;; CHECK-NEXT:    (struct.new $A
  ;; CHECK-NEXT:     (i32.const 20)
  ;; CHECK-NEXT:     (i32.const 22)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $A 1
  ;; CHECK-NEXT:    (local.get $ref)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $A (param $x i32)
    (local $ref (ref null $A))
    (if
      (local.get $x)
      (local.set $ref
        (struct.new $A
          (i32.const 10)
          (i32.const 10)
        )
      )
      (local.set $ref
        (struct.new $A
          (i32.const 20)
          (i32.const 22) ;; This changed, so we do not optimize. One struct.new
                         ;; without the proper equivalences stops us.
        )
      )
    )
    (drop
      (struct.get $A 1
        (local.get $ref)
      )
    )
  )
)

(module
  ;; CHECK:      (type $A (struct (field i32) (field i32)))
  (type $A (struct (field i32) (field i32)))

  ;; CHECK:      (func $A (type $i32_=>_none) (param $x i32)
  ;; CHECK-NEXT:  (local $ref (ref null $A))
  ;; CHECK-NEXT:  (if
  ;; CHECK-NEXT:   (local.get $x)
  ;; CHECK-NEXT:   (local.set $ref
  ;; CHECK-NEXT:    (struct.new $A
  ;; CHECK-NEXT:     (i32.const 10)
  ;; CHECK-NEXT:     (i32.const 11)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:   (local.set $ref
  ;; CHECK-NEXT:    (struct.new $A
  ;; CHECK-NEXT:     (i32.const 20)
  ;; CHECK-NEXT:     (i32.const 20)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $A 1
  ;; CHECK-NEXT:    (local.get $ref)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $A (param $x i32)
    (local $ref (ref null $A))
    (if
      (local.get $x)
      (local.set $ref
        (struct.new $A
          (i32.const 10)
          (i32.const 11) ;; This changed, so we do not optimize. This is the
                         ;; same as the last testcase, but now the lack of
                         ;; equivalence is in the first struct.new.
        )
      )
      (local.set $ref
        (struct.new $A
          (i32.const 20)
          (i32.const 20)
        )
      )
    )
    (drop
      (struct.get $A 1
        (local.get $ref)
      )
    )
  )
)

;; Test separate functions and a struct.new in a global. Here we can optimize.
(module
  ;; CHECK:      (type $A (struct (field i32) (field i32)))
  (type $A (struct (field i32) (field i32)))

  ;; CHECK:      (global $A (ref $A) (struct.new $A
  ;; CHECK-NEXT:  (i32.const 10)
  ;; CHECK-NEXT:  (i32.const 10)
  ;; CHECK-NEXT: ))
  (global $A (ref $A) (struct.new $A
    (i32.const 10)
    (i32.const 10)
  ))

  ;; CHECK:      (func $new-0 (type $none_=>_none)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.new $A
  ;; CHECK-NEXT:    (i32.const 20)
  ;; CHECK-NEXT:    (i32.const 20)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $new-0
    (drop
      (struct.new $A
        (i32.const 20)
        (i32.const 20)
      )
    )
  )

  ;; CHECK:      (func $new-1 (type $none_=>_none)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.new $A
  ;; CHECK-NEXT:    (i32.const 20)
  ;; CHECK-NEXT:    (i32.const 20)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $new-1
    (drop
      (struct.new $A
        (i32.const 20)
        (i32.const 20)
      )
    )
  )

  ;; CHECK:      (func $get (type $ref|$A|_=>_i32) (param $ref (ref $A)) (result i32)
  ;; CHECK-NEXT:  (struct.get $A 0
  ;; CHECK-NEXT:   (local.get $ref)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $get (param $ref (ref $A)) (result i32)
    (struct.get $A 1
      (local.get $ref)
    )
  )
)

;; Non-equivalence in the global prevents optimization.
(module
  ;; CHECK:      (type $A (struct (field i32) (field i32)))
  (type $A (struct (field i32) (field i32)))

  ;; CHECK:      (global $A (ref $A) (struct.new $A
  ;; CHECK-NEXT:  (i32.const 10)
  ;; CHECK-NEXT:  (i32.const 11)
  ;; CHECK-NEXT: ))
  (global $A (ref $A) (struct.new $A
    (i32.const 10)
    (i32.const 11) ;; This changed.
  ))

  ;; CHECK:      (func $new-0 (type $none_=>_none)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.new $A
  ;; CHECK-NEXT:    (i32.const 20)
  ;; CHECK-NEXT:    (i32.const 20)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $new-0
    (drop
      (struct.new $A
        (i32.const 20)
        (i32.const 20)
      )
    )
  )

  ;; CHECK:      (func $new-1 (type $none_=>_none)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.new $A
  ;; CHECK-NEXT:    (i32.const 20)
  ;; CHECK-NEXT:    (i32.const 20)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $new-1
    (drop
      (struct.new $A
        (i32.const 20)
        (i32.const 20)
      )
    )
  )

  ;; CHECK:      (func $get (type $ref|$A|_=>_i32) (param $ref (ref $A)) (result i32)
  ;; CHECK-NEXT:  (struct.get $A 1
  ;; CHECK-NEXT:   (local.get $ref)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $get (param $ref (ref $A)) (result i32)
    (struct.get $A 1
      (local.get $ref)
    )
  )
)

;; Non-equivalence in a function prevents optimization.
(module
  ;; CHECK:      (type $A (struct (field i32) (field i32)))
  (type $A (struct (field i32) (field i32)))

  ;; CHECK:      (global $A (ref $A) (struct.new $A
  ;; CHECK-NEXT:  (i32.const 10)
  ;; CHECK-NEXT:  (i32.const 10)
  ;; CHECK-NEXT: ))
  (global $A (ref $A) (struct.new $A
    (i32.const 10)
    (i32.const 10)
  ))

  ;; CHECK:      (func $new-0 (type $none_=>_none)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.new $A
  ;; CHECK-NEXT:    (i32.const 20)
  ;; CHECK-NEXT:    (i32.const 20)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $new-0
    (drop
      (struct.new $A
        (i32.const 20)
        (i32.const 20)
      )
    )
  )

  ;; CHECK:      (func $new-1 (type $none_=>_none)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.new $A
  ;; CHECK-NEXT:    (i32.const 20)
  ;; CHECK-NEXT:    (i32.const 22)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $new-1
    (drop
      (struct.new $A
        (i32.const 20)
        (i32.const 22) ;; This changed.
      )
    )
  )

  ;; CHECK:      (func $get (type $ref|$A|_=>_i32) (param $ref (ref $A)) (result i32)
  ;; CHECK-NEXT:  (struct.get $A 1
  ;; CHECK-NEXT:   (local.get $ref)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $get (param $ref (ref $A)) (result i32)
    (struct.get $A 1
      (local.get $ref)
    )
  )
)

;; Four fields.
(module
  ;; CHECK:      (type $A (struct (field i32) (field i32) (field i32) (field i32)))
  (type $A (struct (field i32) (field i32) (field i32) (field i32)))

  ;; CHECK:      (func $A (type $i32_=>_none) (param $x i32)
  ;; CHECK-NEXT:  (local $ref (ref null $A))
  ;; CHECK-NEXT:  (if
  ;; CHECK-NEXT:   (local.get $x)
  ;; CHECK-NEXT:   (local.set $ref
  ;; CHECK-NEXT:    (struct.new $A
  ;; CHECK-NEXT:     (i32.const 10)
  ;; CHECK-NEXT:     (i32.const 10)
  ;; CHECK-NEXT:     (i32.const 20)
  ;; CHECK-NEXT:     (i32.const 20)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:   (local.set $ref
  ;; CHECK-NEXT:    (struct.new $A
  ;; CHECK-NEXT:     (i32.const 10)
  ;; CHECK-NEXT:     (i32.const 20)
  ;; CHECK-NEXT:     (i32.const 20)
  ;; CHECK-NEXT:     (i32.const 30)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $A 0
  ;; CHECK-NEXT:    (local.get $ref)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $A 1
  ;; CHECK-NEXT:    (local.get $ref)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $A 2
  ;; CHECK-NEXT:    (local.get $ref)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $A 3
  ;; CHECK-NEXT:    (local.get $ref)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $A (param $x i32)
    (local $ref (ref null $A))
    (if
      (local.get $x)
      (local.set $ref
        (struct.new $A
          (i32.const 10) ;; Here the first two and last two are equivalent.
          (i32.const 10)
          (i32.const 20)
          (i32.const 20)
        )
      )
      (local.set $ref
        (struct.new $A
          (i32.const 10)
          (i32.const 20) ;; Here the middle two are equivalent. No overlap in
          (i32.const 20) ;; equivalences, so nothing is optimized below.
          (i32.const 30)
        )
      )
    )
    (drop
      (struct.get $A 0
        (local.get $ref)
      )
    )
    (drop
      (struct.get $A 1
        (local.get $ref)
      )
    )
    (drop
      (struct.get $A 2
        (local.get $ref)
      )
    )
    (drop
      (struct.get $A 3
        (local.get $ref)
      )
    )
  )
)

;; Four fields, now with optimizability.
(module
  ;; CHECK:      (type $A (struct (field i32) (field i32) (field i32) (field i32)))
  (type $A (struct (field i32) (field i32) (field i32) (field i32)))

  ;; CHECK:      (func $A (type $i32_=>_none) (param $x i32)
  ;; CHECK-NEXT:  (local $ref (ref null $A))
  ;; CHECK-NEXT:  (if
  ;; CHECK-NEXT:   (local.get $x)
  ;; CHECK-NEXT:   (local.set $ref
  ;; CHECK-NEXT:    (struct.new $A
  ;; CHECK-NEXT:     (i32.const 10)
  ;; CHECK-NEXT:     (i32.const 10)
  ;; CHECK-NEXT:     (i32.const 20)
  ;; CHECK-NEXT:     (i32.const 20)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:   (local.set $ref
  ;; CHECK-NEXT:    (struct.new $A
  ;; CHECK-NEXT:     (i32.const 10)
  ;; CHECK-NEXT:     (i32.const 20)
  ;; CHECK-NEXT:     (i32.const 20)
  ;; CHECK-NEXT:     (i32.const 20)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $A 0
  ;; CHECK-NEXT:    (local.get $ref)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $A 1
  ;; CHECK-NEXT:    (local.get $ref)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $A 2
  ;; CHECK-NEXT:    (local.get $ref)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $A 2
  ;; CHECK-NEXT:    (local.get $ref)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $A (param $x i32)
    (local $ref (ref null $A))
    (if
      (local.get $x)
      (local.set $ref
        (struct.new $A
          (i32.const 10)
          (i32.const 10)
          (i32.const 20)
          (i32.const 20)
        )
      )
      (local.set $ref
        (struct.new $A
          (i32.const 10)
          (i32.const 20) ;; Now the last three are equivalent. Combining with
          (i32.const 20) ;; the previous new, the last two remain equivalent.
          (i32.const 20)
        )
      )
    )
    (drop
      (struct.get $A 0
        (local.get $ref)
      )
    )
    (drop
      (struct.get $A 1
        (local.get $ref)
      )
    )
    (drop
      (struct.get $A 2
        (local.get $ref)
      )
    )
    (drop
      (struct.get $A 3   ;; This will be optimized to index 2.
        (local.get $ref)
      )
    )
  )
)

;; As above, but now in both struct.news we have the same intended optimization,
;; so we succeed.
(module
  ;; CHECK:      (type $A (struct (field i32) (field i32) (field i32) (field i32)))
  (type $A (struct (field i32) (field i32) (field i32) (field i32)))

  ;; CHECK:      (func $A (type $i32_=>_none) (param $x i32)
  ;; CHECK-NEXT:  (local $ref (ref null $A))
  ;; CHECK-NEXT:  (if
  ;; CHECK-NEXT:   (local.get $x)
  ;; CHECK-NEXT:   (local.set $ref
  ;; CHECK-NEXT:    (struct.new $A
  ;; CHECK-NEXT:     (i32.const 10)
  ;; CHECK-NEXT:     (i32.const 10)
  ;; CHECK-NEXT:     (i32.const 20)
  ;; CHECK-NEXT:     (i32.const 20)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:   (local.set $ref
  ;; CHECK-NEXT:    (struct.new $A
  ;; CHECK-NEXT:     (i32.const 10)
  ;; CHECK-NEXT:     (i32.const 15)
  ;; CHECK-NEXT:     (i32.const 20)
  ;; CHECK-NEXT:     (i32.const 20)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $A 0
  ;; CHECK-NEXT:    (local.get $ref)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $A 1
  ;; CHECK-NEXT:    (local.get $ref)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $A 2
  ;; CHECK-NEXT:    (local.get $ref)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $A 2
  ;; CHECK-NEXT:    (local.get $ref)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $A (param $x i32)
    (local $ref (ref null $A))
    (if
      (local.get $x)
      (local.set $ref
        (struct.new $A
          (i32.const 10)
          (i32.const 10)
          (i32.const 20)
          (i32.const 20)
        )
      )
      (local.set $ref
        (struct.new $A
          (i32.const 10)
          (i32.const 15) ;; This changed. Now we'd like to improve 3 to 2 in
          (i32.const 20) ;; both struct.news, and will do so.
          (i32.const 20)
        )
      )
    )
    (drop
      (struct.get $A 0
        (local.get $ref)
      )
    )
    (drop
      (struct.get $A 1
        (local.get $ref)
      )
    )
    (drop
      (struct.get $A 2
        (local.get $ref)
      )
    )
    (drop
      (struct.get $A 3
        (local.get $ref)
      )
    )
  )
)

;; Four fields, two pairs of whom are equivalent.
(module
  ;; CHECK:      (type $A (struct (field i32) (field i32) (field i32) (field i32)))
  (type $A (struct (field i32) (field i32) (field i32) (field i32)))

  ;; CHECK:      (func $A (type $none_=>_none)
  ;; CHECK-NEXT:  (local $ref (ref null $A))
  ;; CHECK-NEXT:  (local.set $ref
  ;; CHECK-NEXT:   (struct.new $A
  ;; CHECK-NEXT:    (i32.const 10)
  ;; CHECK-NEXT:    (i32.const 10)
  ;; CHECK-NEXT:    (i32.const 20)
  ;; CHECK-NEXT:    (i32.const 20)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $A 0
  ;; CHECK-NEXT:    (local.get $ref)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $A 0
  ;; CHECK-NEXT:    (local.get $ref)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $A 2
  ;; CHECK-NEXT:    (local.get $ref)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $A 2
  ;; CHECK-NEXT:    (local.get $ref)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $A
    (local $ref (ref null $A))
    (local.set $ref
      (struct.new $A
        (i32.const 10) ;; The first two and last two are equivalent, so we have
        (i32.const 10) ;; multiple optimization opportunities in a single type.
        (i32.const 20)
        (i32.const 20)
      )
    )
    (drop
      (struct.get $A 0
        (local.get $ref)
      )
    )
    (drop
      (struct.get $A 1
        (local.get $ref)
      )
    )
    (drop
      (struct.get $A 2
        (local.get $ref)
      )
    )
    (drop
      (struct.get $A 3
        (local.get $ref)
      )
    )
  )
)

;; Four fields, three of whom are equivalent.
(module
  ;; CHECK:      (type $A (struct (field i32) (field i32) (field i32) (field i32)))
  (type $A (struct (field i32) (field i32) (field i32) (field i32)))

  ;; CHECK:      (func $A (type $none_=>_none)
  ;; CHECK-NEXT:  (local $ref (ref null $A))
  ;; CHECK-NEXT:  (local.set $ref
  ;; CHECK-NEXT:   (struct.new $A
  ;; CHECK-NEXT:    (i32.const 10)
  ;; CHECK-NEXT:    (i32.const 10)
  ;; CHECK-NEXT:    (i32.const 20)
  ;; CHECK-NEXT:    (i32.const 10)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $A 0
  ;; CHECK-NEXT:    (local.get $ref)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $A 0
  ;; CHECK-NEXT:    (local.get $ref)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $A 2
  ;; CHECK-NEXT:    (local.get $ref)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $A 0
  ;; CHECK-NEXT:    (local.get $ref)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $A
    (local $ref (ref null $A))
    (local.set $ref
      (struct.new $A
        (i32.const 10)
        (i32.const 10)
        (i32.const 20)
        (i32.const 10) ;; The last one is equivalent to the first two.
      )
    )
    (drop
      (struct.get $A 0
        (local.get $ref)
      )
    )
    (drop
      (struct.get $A 1
        (local.get $ref)
      )
    )
    (drop
      (struct.get $A 2
        (local.get $ref)
      )
    )
    (drop
      (struct.get $A 3
        (local.get $ref)
      )
    )
  )
)

;; Mutable fields are not optimizable.
(module
  ;; CHECK:      (type $A (struct (field i32) (field (mut i32))))
  (type $A (struct (field i32) (field (mut i32)))) ;; One field is mutable.

  ;; CHECK:      (func $A (type $none_=>_none)
  ;; CHECK-NEXT:  (local $ref (ref null $A))
  ;; CHECK-NEXT:  (local.set $ref
  ;; CHECK-NEXT:   (struct.new $A
  ;; CHECK-NEXT:    (i32.const 10)
  ;; CHECK-NEXT:    (i32.const 10)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $A 0
  ;; CHECK-NEXT:    (local.get $ref)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $A 1
  ;; CHECK-NEXT:    (local.get $ref)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $A
    (local $ref (ref null $A))
    (local.set $ref
      (struct.new $A
        (i32.const 10)
        (i32.const 10)
      )
    )
    (drop
      (struct.get $A 0
        (local.get $ref)
      )
    )
    (drop
      (struct.get $A 1
        (local.get $ref)
      )
    )
  )
)

;; Non-constant fields: globals and unknowns.
(module
  ;; CHECK:      (type $A (struct (field i32) (field i32) (field i32) (field i32) (field i32) (field i32)))
  (type $A (struct (field i32) (field i32) (field i32) (field i32) (field i32) (field i32)))

  ;; CHECK:      (global $g10 i32 (i32.const 10))
  (global $g10 i32 (i32.const 10))

  ;; CHECK:      (global $g10-mut (mut i32) (i32.const 10))
  (global $g10-mut (mut i32) (i32.const 10))

  ;; CHECK:      (func $A (type $i32_=>_none) (param $x i32)
  ;; CHECK-NEXT:  (local $ref (ref null $A))
  ;; CHECK-NEXT:  (local.set $ref
  ;; CHECK-NEXT:   (struct.new $A
  ;; CHECK-NEXT:    (global.get $g10)
  ;; CHECK-NEXT:    (global.get $g10)
  ;; CHECK-NEXT:    (global.get $g10-mut)
  ;; CHECK-NEXT:    (global.get $g10-mut)
  ;; CHECK-NEXT:    (local.get $x)
  ;; CHECK-NEXT:    (local.get $x)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $A 0
  ;; CHECK-NEXT:    (local.get $ref)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $A 0
  ;; CHECK-NEXT:    (local.get $ref)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $A 2
  ;; CHECK-NEXT:    (local.get $ref)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $A 3
  ;; CHECK-NEXT:    (local.get $ref)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $A 4
  ;; CHECK-NEXT:    (local.get $ref)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $A 5
  ;; CHECK-NEXT:    (local.get $ref)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $A (param $x i32)
    (local $ref (ref null $A))
    (local.set $ref
      (struct.new $A
        ;; Immutable globals - these are equivalent.
        (global.get $g10)
        (global.get $g10)
        ;; Mutable globals, so we cannot optimize.
        (global.get $g10-mut)
        (global.get $g10-mut)
        ;; Completely unknown values.
        (local.get $x)
        (local.get $x)
      )
    )
    (drop
      (struct.get $A 0
        (local.get $ref)
      )
    )
    (drop
      (struct.get $A 1
        (local.get $ref)
      )
    )
    (drop
      (struct.get $A 2
        (local.get $ref)
      )
    )
    (drop
      (struct.get $A 3
        (local.get $ref)
      )
    )
    (drop
      (struct.get $A 4
        (local.get $ref)
      )
    )
    (drop
      (struct.get $A 5
        (local.get $ref)
      )
    )
  )
)

;; Subtyping. Here both types have the same equivalent fields, so we can
;; optimize them all to read field index #0.
(module
  ;; CHECK:      (type $A (struct (field i32) (field i32)))
  (type $A (struct (field i32) (field i32)))
  ;; CHECK:      (type $B (struct_subtype (field i32) (field i32) $A))
  (type $B (struct_subtype (field i32) (field i32) $A))

  ;; CHECK:      (func $A (type $none_=>_none)
  ;; CHECK-NEXT:  (local $A (ref null $A))
  ;; CHECK-NEXT:  (local.set $A
  ;; CHECK-NEXT:   (struct.new $A
  ;; CHECK-NEXT:    (i32.const 10)
  ;; CHECK-NEXT:    (i32.const 10)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $A 0
  ;; CHECK-NEXT:    (local.get $A)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $A 0
  ;; CHECK-NEXT:    (local.get $A)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $A
    (local $A (ref null $A))
    (local.set $A
      (struct.new $A
        (i32.const 10)
        (i32.const 10)
      )
    )
    (drop
      (struct.get $A 0
        (local.get $A)
      )
    )
    (drop
      (struct.get $A 1
        (local.get $A)
      )
    )
  )

  ;; CHECK:      (func $B (type $none_=>_none)
  ;; CHECK-NEXT:  (local $B (ref null $B))
  ;; CHECK-NEXT:  (local.set $B
  ;; CHECK-NEXT:   (struct.new $B
  ;; CHECK-NEXT:    (i32.const 20)
  ;; CHECK-NEXT:    (i32.const 20)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $B 0
  ;; CHECK-NEXT:    (local.get $B)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $B 0
  ;; CHECK-NEXT:    (local.get $B)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $B
    (local $B (ref null $B))
    (local.set $B
      (struct.new $B
        (i32.const 20)
        (i32.const 20)
      )
    )
    (drop
      (struct.get $B 0
        (local.get $B)
      )
    )
    (drop
      (struct.get $B 1
        (local.get $B)
      )
    )
  )
)

;; Subtyping, but now the parent's fields are not equivalent, preventing
;; optimization there. But we can still optimize the child.
(module
  ;; CHECK:      (type $A (struct (field i32) (field i32)))
  (type $A (struct (field i32) (field i32)))
  ;; CHECK:      (type $B (struct_subtype (field i32) (field i32) $A))
  (type $B (struct_subtype (field i32) (field i32) $A))

  ;; CHECK:      (func $A (type $none_=>_none)
  ;; CHECK-NEXT:  (local $A (ref null $A))
  ;; CHECK-NEXT:  (local.set $A
  ;; CHECK-NEXT:   (struct.new $A
  ;; CHECK-NEXT:    (i32.const 10)
  ;; CHECK-NEXT:    (i32.const 11)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $A 0
  ;; CHECK-NEXT:    (local.get $A)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $A 1
  ;; CHECK-NEXT:    (local.get $A)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $A
    (local $A (ref null $A))
    (local.set $A
      (struct.new $A
        (i32.const 10)
        (i32.const 11) ;; This changed.
      )
    )
    (drop
      (struct.get $A 0
        (local.get $A)
      )
    )
    (drop
      (struct.get $A 1
        (local.get $A)
      )
    )
  )

  ;; CHECK:      (func $B (type $none_=>_none)
  ;; CHECK-NEXT:  (local $B (ref null $B))
  ;; CHECK-NEXT:  (local.set $B
  ;; CHECK-NEXT:   (struct.new $B
  ;; CHECK-NEXT:    (i32.const 20)
  ;; CHECK-NEXT:    (i32.const 20)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $B 0
  ;; CHECK-NEXT:    (local.get $B)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $B 0
  ;; CHECK-NEXT:    (local.get $B)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $B
    (local $B (ref null $B))
    (local.set $B
      (struct.new $B
        (i32.const 20)
        (i32.const 20)
      )
    )
    (drop
      (struct.get $B 0
        (local.get $B)
      )
    )
    (drop
      (struct.get $B 1
        (local.get $B)
      )
    )
  )
)

;; Subtyping, but now the child's fields are not equivalent, preventing
;; optimization in both the parent and the child.
(module
  ;; CHECK:      (type $A (struct (field i32) (field i32)))
  (type $A (struct (field i32) (field i32)))
  ;; CHECK:      (type $B (struct_subtype (field i32) (field i32) $A))
  (type $B (struct_subtype (field i32) (field i32) $A))

  ;; CHECK:      (func $A (type $none_=>_none)
  ;; CHECK-NEXT:  (local $A (ref null $A))
  ;; CHECK-NEXT:  (local.set $A
  ;; CHECK-NEXT:   (struct.new $A
  ;; CHECK-NEXT:    (i32.const 10)
  ;; CHECK-NEXT:    (i32.const 10)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $A 0
  ;; CHECK-NEXT:    (local.get $A)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $A 1
  ;; CHECK-NEXT:    (local.get $A)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $A
    (local $A (ref null $A))
    (local.set $A
      (struct.new $A
        (i32.const 10)
        (i32.const 10)
      )
    )
    (drop
      (struct.get $A 0
        (local.get $A)
      )
    )
    (drop
      (struct.get $A 1
        (local.get $A)
      )
    )
  )

  ;; CHECK:      (func $B (type $none_=>_none)
  ;; CHECK-NEXT:  (local $B (ref null $B))
  ;; CHECK-NEXT:  (local.set $B
  ;; CHECK-NEXT:   (struct.new $B
  ;; CHECK-NEXT:    (i32.const 20)
  ;; CHECK-NEXT:    (i32.const 22)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $B 0
  ;; CHECK-NEXT:    (local.get $B)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $B 1
  ;; CHECK-NEXT:    (local.get $B)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $B
    (local $B (ref null $B))
    (local.set $B
      (struct.new $B
        (i32.const 20)
        (i32.const 22) ;; This changed.
      )
    )
    (drop
      (struct.get $B 0
        (local.get $B)
      )
    )
    (drop
      (struct.get $B 1
        (local.get $B)
      )
    )
  )
)

;; Nested struct.news.
(module
  ;; CHECK:      (type $A (struct (field (ref $B)) (field i32)))
  (type $A (struct (field (ref $B)) (field i32)))
  ;; CHECK:      (type $B (struct (field i32) (field i32)))
  (type $B (struct (field i32) (field i32)))

  ;; CHECK:      (func $A (type $none_=>_none)
  ;; CHECK-NEXT:  (local $ref (ref null $A))
  ;; CHECK-NEXT:  (local.set $ref
  ;; CHECK-NEXT:   (struct.new $A
  ;; CHECK-NEXT:    (struct.new $B
  ;; CHECK-NEXT:     (i32.const 10)
  ;; CHECK-NEXT:     (i32.const 20)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (i32.const 20)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $A 0
  ;; CHECK-NEXT:    (local.get $ref)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $B 0
  ;; CHECK-NEXT:    (struct.get $A 0
  ;; CHECK-NEXT:     (local.get $ref)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $A 1
  ;; CHECK-NEXT:    (local.get $ref)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $A 1
  ;; CHECK-NEXT:    (local.get $ref)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $A
    (local $ref (ref null $A))
    (local.set $ref
      (struct.new $A
        (struct.new $B
          (i32.const 10)
          (i32.const 20) ;; This field of $B is the same as one of $A.
        )
        (i32.const 20)
      )
    )
    (drop
      (struct.get $A 0
        (local.get $ref)
      )
    )
    (drop
      (struct.get $B 0
        (struct.get $A 0
          (local.get $ref)
        )
      )
    )
    (drop
      (struct.get $B 1     ;; This can read from $A.1 instead of $A.B.1.
        (struct.get $A 0
          (local.get $ref)
        )
      )
    )
    (drop
      (struct.get $A 1
        (local.get $ref)
      )
    )
  )
)

;; As above, but reorder a field to make sure we don't confuse field indexes in
;; A with B.
(module
  ;; CHECK:      (type $A (struct (field (ref $B)) (field i32)))
  (type $A (struct (field (ref $B)) (field i32)))
  ;; CHECK:      (type $B (struct (field i32) (field i32)))
  (type $B (struct (field i32) (field i32)))

  ;; CHECK:      (func $A (type $none_=>_none)
  ;; CHECK-NEXT:  (local $ref (ref null $A))
  ;; CHECK-NEXT:  (local.set $ref
  ;; CHECK-NEXT:   (struct.new $A
  ;; CHECK-NEXT:    (struct.new $B
  ;; CHECK-NEXT:     (i32.const 20)
  ;; CHECK-NEXT:     (i32.const 10)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (i32.const 20)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $A 0
  ;; CHECK-NEXT:    (local.get $ref)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $A 1
  ;; CHECK-NEXT:    (local.get $ref)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $B 1
  ;; CHECK-NEXT:    (struct.get $A 0
  ;; CHECK-NEXT:     (local.get $ref)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $A 1
  ;; CHECK-NEXT:    (local.get $ref)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $A
    (local $ref (ref null $A))
    (local.set $ref
      (struct.new $A
        (struct.new $B
          (i32.const 20) ;; These are reordered
          (i32.const 10)
        )
        (i32.const 20)
      )
    )
    (drop
      (struct.get $A 0
        (local.get $ref)
      )
    )
    (drop
      (struct.get $B 0     ;; Since we reordered, we can optimize here instead
        (struct.get $A 0   ;; the case below.
          (local.get $ref)
        )
      )
    )
    (drop
      (struct.get $B 1
        (struct.get $A 0
          (local.get $ref)
        )
      )
    )
    (drop
      (struct.get $A 1
        (local.get $ref)
      )
    )
  )
)

;; As above, but now the nesting goes into a global. We can still optimize as it
;; is immutable.
(module
  ;; CHECK:      (type $A (struct (field (ref $B)) (field i32)))
  (type $A (struct (field (ref $B)) (field i32)))
  ;; CHECK:      (type $B (struct (field i32) (field i32)))
  (type $B (struct (field i32) (field i32)))

  ;; CHECK:      (global $B (ref $B) (struct.new $B
  ;; CHECK-NEXT:  (i32.const 10)
  ;; CHECK-NEXT:  (i32.const 20)
  ;; CHECK-NEXT: ))
  (global $B (ref $B) (struct.new $B
    (i32.const 10)
    (i32.const 20) ;; This field of $B is the same as one of $A.
  ))

  ;; CHECK:      (func $A (type $none_=>_none)
  ;; CHECK-NEXT:  (local $ref (ref null $A))
  ;; CHECK-NEXT:  (local.set $ref
  ;; CHECK-NEXT:   (struct.new $A
  ;; CHECK-NEXT:    (global.get $B)
  ;; CHECK-NEXT:    (i32.const 20)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $A 0
  ;; CHECK-NEXT:    (local.get $ref)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $B 0
  ;; CHECK-NEXT:    (struct.get $A 0
  ;; CHECK-NEXT:     (local.get $ref)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $A 1
  ;; CHECK-NEXT:    (local.get $ref)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $A 1
  ;; CHECK-NEXT:    (local.get $ref)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $A
    (local $ref (ref null $A))
    (local.set $ref
      (struct.new $A
        (global.get $B)
        (i32.const 20)  ;; This is the same as a field of $B.
      )
    )
    (drop
      (struct.get $A 0
        (local.get $ref)
      )
    )
    (drop
      (struct.get $B 0
        (struct.get $A 0
          (local.get $ref)
        )
      )
    )
    (drop
      (struct.get $B 1     ;; This can read from $A.1 instead of $A.B.1.
        (struct.get $A 0
          (local.get $ref)
        )
      )
    )
    (drop
      (struct.get $A 1
        (local.get $ref)
      )
    )
  )
)

;; As above, but the global is mutable, so we do not optimize.
(module
  ;; CHECK:      (type $A (struct (field (ref $B)) (field i32)))
  (type $A (struct (field (ref $B)) (field i32)))
  ;; CHECK:      (type $B (struct (field i32) (field i32)))
  (type $B (struct (field i32) (field i32)))

  ;; CHECK:      (global $B (mut (ref $B)) (struct.new $B
  ;; CHECK-NEXT:  (i32.const 10)
  ;; CHECK-NEXT:  (i32.const 20)
  ;; CHECK-NEXT: ))
  (global $B (mut (ref $B)) (struct.new $B
    (i32.const 10)
    (i32.const 20)
  ))

  ;; CHECK:      (func $A (type $none_=>_none)
  ;; CHECK-NEXT:  (local $ref (ref null $A))
  ;; CHECK-NEXT:  (local.set $ref
  ;; CHECK-NEXT:   (struct.new $A
  ;; CHECK-NEXT:    (global.get $B)
  ;; CHECK-NEXT:    (i32.const 20)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $A 0
  ;; CHECK-NEXT:    (local.get $ref)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $B 0
  ;; CHECK-NEXT:    (struct.get $A 0
  ;; CHECK-NEXT:     (local.get $ref)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $B 1
  ;; CHECK-NEXT:    (struct.get $A 0
  ;; CHECK-NEXT:     (local.get $ref)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $A 1
  ;; CHECK-NEXT:    (local.get $ref)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $A
    (local $ref (ref null $A))
    (local.set $ref
      (struct.new $A
        (global.get $B)
        (i32.const 20)
      )
    )
    (drop
      (struct.get $A 0
        (local.get $ref)
      )
    )
    (drop
      (struct.get $B 0
        (struct.get $A 0
          (local.get $ref)
        )
      )
    )
    (drop
      (struct.get $B 1
        (struct.get $A 0
          (local.get $ref)
        )
      )
    )
    (drop
      (struct.get $A 1
        (local.get $ref)
      )
    )
  )
)

;; As above, but the global is imported. We cannot optimize here.
(module
  ;; CHECK:      (type $A (struct (field (ref $B)) (field i32)))
  (type $A (struct (field (ref $B)) (field i32)))
  ;; CHECK:      (type $B (struct (field i32) (field i32)))
  (type $B (struct (field i32) (field i32)))

  ;; CHECK:      (import "a" "b" (global $B (ref $B)))
  (import "a" "b" (global $B (ref $B)))

  ;; CHECK:      (func $A (type $none_=>_none)
  ;; CHECK-NEXT:  (local $ref (ref null $A))
  ;; CHECK-NEXT:  (local.set $ref
  ;; CHECK-NEXT:   (struct.new $A
  ;; CHECK-NEXT:    (global.get $B)
  ;; CHECK-NEXT:    (i32.const 20)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $A 0
  ;; CHECK-NEXT:    (local.get $ref)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $B 0
  ;; CHECK-NEXT:    (struct.get $A 0
  ;; CHECK-NEXT:     (local.get $ref)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $B 1
  ;; CHECK-NEXT:    (struct.get $A 0
  ;; CHECK-NEXT:     (local.get $ref)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $A 1
  ;; CHECK-NEXT:    (local.get $ref)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $A
    (local $ref (ref null $A))
    (local.set $ref
      (struct.new $A
        (global.get $B)
        (i32.const 20)
      )
    )
    (drop
      (struct.get $A 0
        (local.get $ref)
      )
    )
    (drop
      (struct.get $B 0
        (struct.get $A 0
          (local.get $ref)
        )
      )
    )
    (drop
      (struct.get $B 1
        (struct.get $A 0
          (local.get $ref)
        )
      )
    )
    (drop
      (struct.get $A 1
        (local.get $ref)
      )
    )
  )
)

;; Realistic vtable scenario. This is something no other optimization can handle
;; as we cannot simply infer the called function here - only this pass can see
;; that different fields are equivalent *without* knowing the actual function
;; references. Using that, we can switch the get to the lower index.
;;
;; This also tests function references being optimized.
(module
  ;; CHECK:      (type $vtable (struct (field $op1 funcref) (field $op2 funcref)))
  (type $vtable (struct (field $op1 funcref) (field $op2 funcref)))

  ;; CHECK:      (type $A (struct (field $vtable (ref $vtable))))
  (type $A (struct (field $vtable (ref $vtable))))
  ;; CHECK:      (type $B (struct_subtype (field $vtable (ref $vtable)) $A))
  (type $B (struct_subtype (field $vtable (ref $vtable)) $A))

  ;; CHECK:      (global $vtable-A (ref $vtable) (struct.new $vtable
  ;; CHECK-NEXT:  (ref.func $func-a)
  ;; CHECK-NEXT:  (ref.func $func-a)
  ;; CHECK-NEXT: ))
  (global $vtable-A (ref $vtable) (struct.new $vtable
    (ref.func $func-a)
    (ref.func $func-a)
  ))

  ;; CHECK:      (global $vtable-B (ref $vtable) (struct.new $vtable
  ;; CHECK-NEXT:  (ref.func $func-b)
  ;; CHECK-NEXT:  (ref.func $func-b)
  ;; CHECK-NEXT: ))
  (global $vtable-B (ref $vtable) (struct.new $vtable
    (ref.func $func-b)
    (ref.func $func-b)
  ))

  ;; CHECK:      (func $func-a (type $none_=>_i32) (result i32)
  ;; CHECK-NEXT:  (i32.const 10)
  ;; CHECK-NEXT: )
  (func $func-a (result i32)
    (i32.const 10)
  )

  ;; CHECK:      (func $func-b (type $none_=>_i32) (result i32)
  ;; CHECK-NEXT:  (i32.const 10)
  ;; CHECK-NEXT: )
  (func $func-b (result i32)
    (i32.const 10)
  )

  ;; CHECK:      (func $A (type $i32_=>_none) (param $x i32)
  ;; CHECK-NEXT:  (local $ref (ref null $A))
  ;; CHECK-NEXT:  (if
  ;; CHECK-NEXT:   (local.get $x)
  ;; CHECK-NEXT:   (local.set $ref
  ;; CHECK-NEXT:    (struct.new $A
  ;; CHECK-NEXT:     (global.get $vtable-A)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:   (local.set $ref
  ;; CHECK-NEXT:    (struct.new $B
  ;; CHECK-NEXT:     (global.get $vtable-B)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $vtable $op1
  ;; CHECK-NEXT:    (struct.get $A $vtable
  ;; CHECK-NEXT:     (local.get $ref)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $vtable $op1
  ;; CHECK-NEXT:    (struct.get $A $vtable
  ;; CHECK-NEXT:     (local.get $ref)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $A (param $x i32)
    (local $ref (ref null $A))
    (if
      (local.get $x)
      (local.set $ref
        (struct.new $A
          (global.get $vtable-A)
        )
      )
      (local.set $ref
        (struct.new $B
          (global.get $vtable-B)
        )
      )
    )
    (drop
      (struct.get $vtable $op1
        (struct.get $A $vtable
          (local.get $ref)
        )
      )
    )
    (drop
      (struct.get $vtable $op2 ;; This will be switched to op1.
        (struct.get $A $vtable
          (local.get $ref)
        )
      )
    )
  )
)

;; A case where we can remove a cast.
;;
;; Type A contains B1 and B2, but one field has type struct, so after we read from
;; it we'd need to cast to read its field. We avoid the cast by switching to a
;; read from the other one.
(module
  ;; CHECK:      (type $A (struct (field (ref $B1)) (field (ref struct))))

  ;; CHECK:      (type $B1 (struct (field i32)))
  (type $B1 (struct (field i32)))

  ;; CHECK:      (type $B2 (struct (field i32)))
  (type $B2 (struct (field i32)))

  (type $A (struct (field (ref $B1)) (field (ref struct))))

  ;; CHECK:      (func $A (type $none_=>_none)
  ;; CHECK-NEXT:  (local $ref (ref null $A))
  ;; CHECK-NEXT:  (local.set $ref
  ;; CHECK-NEXT:   (struct.new $A
  ;; CHECK-NEXT:    (struct.new $B1
  ;; CHECK-NEXT:     (i32.const 10)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (struct.new $B2
  ;; CHECK-NEXT:     (i32.const 10)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $B1 0
  ;; CHECK-NEXT:    (struct.get $A 0
  ;; CHECK-NEXT:     (local.get $ref)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $B1 0
  ;; CHECK-NEXT:    (struct.get $A 0
  ;; CHECK-NEXT:     (local.get $ref)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $A
    (local $ref (ref null $A))
    (local.set $ref
      (struct.new $A
        (struct.new $B1
          (i32.const 10)
        )
        (struct.new $B2
          (i32.const 10)
        )
      )
    )
    (drop
      (struct.get $B1 0
        (struct.get $A 0
          (local.get $ref)
        )
      )
    )
    (drop
      (struct.get $B2 0
        (ref.cast $B2        ;; We can avoid this cast by reading from A's
          (struct.get $A 1   ;; field #0 instead, turning this sequence into
            (local.get $ref) ;; the same as the one above.
          )
        )
      )
    )
  )
)

;; As above, but flip the fields so now struct is where B1 would be, and there is
;; a ref of B2. Now B1 needs a cast to be read from, and we'll optimize to use
;; B2 instead.
(module
  ;; CHECK:      (type $A (struct (field (ref struct)) (field (ref $B2))))

  ;; CHECK:      (type $B2 (struct (field i32)))

  ;; CHECK:      (type $B1 (struct (field i32)))
  (type $B1 (struct (field i32)))

  (type $B2 (struct (field i32)))

  (type $A (struct (field (ref struct)) (field (ref $B2)))) ;; change is here

  ;; CHECK:      (func $A (type $none_=>_none)
  ;; CHECK-NEXT:  (local $ref (ref null $A))
  ;; CHECK-NEXT:  (local.set $ref
  ;; CHECK-NEXT:   (struct.new $A
  ;; CHECK-NEXT:    (struct.new $B1
  ;; CHECK-NEXT:     (i32.const 10)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (struct.new $B2
  ;; CHECK-NEXT:     (i32.const 10)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $B2 0
  ;; CHECK-NEXT:    (struct.get $A 1
  ;; CHECK-NEXT:     (local.get $ref)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $B2 0
  ;; CHECK-NEXT:    (struct.get $A 1
  ;; CHECK-NEXT:     (local.get $ref)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $A
    (local $ref (ref null $A))
    (local.set $ref
      (struct.new $A
        (struct.new $B1
          (i32.const 10)
        )
        (struct.new $B2
          (i32.const 10)
        )
      )
    )
    (drop
      (struct.get $B1 0
        (ref.cast $B1
          (struct.get $A 0
            (local.get $ref)
          )
        )
      )
    )
    (drop
      (struct.get $B2 0
        (struct.get $A 1
          (local.get $ref)
        )
      )
    )
  )
)

(module
  ;; CHECK:      (type $A (struct (field i32) (field i32) (field i32) (field i32) (field i32) (field i32) (field i32) (field i32)))
  (type $A (struct (field i32) (field i32) (field i32) (field i32) (field i32) (field i32) (field i32) (field i32)))

  ;; CHECK:      (func $A (type $none_=>_none)
  ;; CHECK-NEXT:  (local $x i32)
  ;; CHECK-NEXT:  (local $default i32)
  ;; CHECK-NEXT:  (local $ref (ref $A))
  ;; CHECK-NEXT:  (local.set $ref
  ;; CHECK-NEXT:   (struct.new $A
  ;; CHECK-NEXT:    (local.tee $x
  ;; CHECK-NEXT:     (local.tee $x
  ;; CHECK-NEXT:      (i32.const 10)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (i32.const 10)
  ;; CHECK-NEXT:    (i32.const 11)
  ;; CHECK-NEXT:    (local.tee $x
  ;; CHECK-NEXT:     (local.get $x)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (local.get $x)
  ;; CHECK-NEXT:    (local.tee $x
  ;; CHECK-NEXT:     (i32.const 12)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (local.get $x)
  ;; CHECK-NEXT:    (local.get $default)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $A 0
  ;; CHECK-NEXT:    (local.get $ref)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $A 0
  ;; CHECK-NEXT:    (local.get $ref)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $A 2
  ;; CHECK-NEXT:    (local.get $ref)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $A 0
  ;; CHECK-NEXT:    (local.get $ref)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $A 0
  ;; CHECK-NEXT:    (local.get $ref)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $A 5
  ;; CHECK-NEXT:    (local.get $ref)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $A 5
  ;; CHECK-NEXT:    (local.get $ref)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $A 7
  ;; CHECK-NEXT:    (local.get $ref)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $A
    (local $x i32)
    (local $default i32)
    (local $ref (ref $A))

    ;; $A is always written the same value in all fields, so they are
    ;; equivalent, and we optimize to always read from field #0. We can do so
    ;; even though local operations are used.
    (local.set $ref
      (struct.new $A
        ;; Nested tees.
        (local.tee $x
          (local.tee $x
            (i32.const 10)
          )
        )
        ;; This is the same value as in the tee.
        (i32.const 10)
        ;; A different value.
        (i32.const 11)
        ;; This is 10 once more.
        (local.tee $x
          (local.get $x)
        )
        ;; This is also 10.
        (local.get $x)
        ;; A different value.
        (local.tee $x
          (i32.const 12)
        )
        ;; The same as the last field.
        (local.get $x)
        ;; Test using the default (null) value.
        (local.get $default)
      )
    )

    (drop
      (struct.get $A 0
        (local.get $ref)
      )
    )

    (drop
      (struct.get $A 1   ;; this can use index #0
        (local.get $ref)
      )
    )
    (drop
      (struct.get $A 2
        (local.get $ref)
      )
    )
    (drop
      (struct.get $A 3   ;; this can use index #0
        (local.get $ref)
      )
    )
    (drop
      (struct.get $A 4   ;; this can use index #0
        (local.get $ref)
      )
    )
    (drop
      (struct.get $A 5
        (local.get $ref)
      )
    )
    (drop
      (struct.get $A 6   ;; this can use index #5
        (local.get $ref)
      )
    )
    (drop
      (struct.get $A 7
        (local.get $ref)
      )
    )
  )
)

;; A case where we can remove a cast even with tees and local.gets.
(module
  ;; CHECK:      (type $A (struct (field (ref $B1)) (field (ref struct))))

  ;; CHECK:      (type $B1 (struct (field i32)))
  (type $B1 (struct (field i32)))

  ;; CHECK:      (type $B2 (struct (field i32)))
  (type $B2 (struct (field i32)))

  (type $A (struct (field (ref $B1)) (field (ref struct))))

  ;; CHECK:      (func $A (type $none_=>_none)
  ;; CHECK-NEXT:  (local $ref (ref null $A))
  ;; CHECK-NEXT:  (local $B1 (ref $B1))
  ;; CHECK-NEXT:  (local $B2 (ref $B2))
  ;; CHECK-NEXT:  (local $struct (ref struct))
  ;; CHECK-NEXT:  (local $temp (ref $B2))
  ;; CHECK-NEXT:  (local $5 (ref null $A))
  ;; CHECK-NEXT:  (local.set $ref
  ;; CHECK-NEXT:   (struct.new $A
  ;; CHECK-NEXT:    (struct.new $B1
  ;; CHECK-NEXT:     (i32.const 10)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (struct.new $B2
  ;; CHECK-NEXT:     (i32.const 10)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (local.set $B1
  ;; CHECK-NEXT:   (struct.get $A 0
  ;; CHECK-NEXT:    (local.get $ref)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $B1 0
  ;; CHECK-NEXT:    (local.get $B1)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (local.set $struct
  ;; CHECK-NEXT:   (struct.get $A 1
  ;; CHECK-NEXT:    (local.tee $5
  ;; CHECK-NEXT:     (local.get $ref)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (local.set $B2
  ;; CHECK-NEXT:   (ref.cast $B2
  ;; CHECK-NEXT:    (local.get $struct)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $B1 0
  ;; CHECK-NEXT:    (struct.get $A 0
  ;; CHECK-NEXT:     (local.get $5)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $A
    (local $ref (ref null $A))
    (local $B1 (ref $B1))
    (local $B2 (ref $B2))
    (local $struct (ref struct))
    (local $temp (ref $B2))

    (local.set $ref
      (struct.new $A
        (struct.new $B1
          (i32.const 10)
        )
        (struct.new $B2
          (i32.const 10)
        )
      )
    )
    (local.set $B1
      (struct.get $A 0
        (local.get $ref)
      )
    )
    (drop
      (struct.get $B1 0
        (local.get $B1)
      )
    )
    (local.set $struct
      (struct.get $A 1
        (local.get $ref)
      )
    )
    (local.set $B2
      (ref.cast $B2
        (local.get $struct)
      )
    )
    (drop
      ;; We can replace this sequence with one that reads from $B1, and avoids a
      ;; cast. While doing so, we'll create a temp local for $ref two
      ;; instructions back, as we are skipping code in the middle which in
      ;; theory could modify $ref.
      (struct.get $B2 0
        (local.tee $temp ;; This local.tee is a side effect we must not remove.
          (local.get $B2)
        )
      )
    )
  )
)
